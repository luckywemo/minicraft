# Chat Test Workflow - End-to-End Testing Sequence

## Overview
This directory contains a comprehensive 13-step test workflow that validates the complete chat functionality from conversation creation through cleanup. The sequence tests critical integration points between assessments and chat conversations.

## Test Workflow Sequence

### Phase 1: Preparation
**01-prepareUserMessageString.js**
- Prepares user message content (6 predefined strings, 2 sentences each)
- Provides variety for testing different conversation scenarios
- Handles message content that would normally be generated by frontend user input

**02-prepareAssessmentId.js** 
- Locates an existing assessment_id from earlier test setup
- Tests the codebase's ability to find assessment_object by assessment_id
- Simulates frontend context where assessment_id is stored
- **Critical validation**: Verifies backend can access assessment data

### Phase 2: Conversation Creation & Validation
**03-createConversation.js**
- Creates new conversation object
- Passes assessment_id as parameter to link conversation with assessment
- Establishes the conversation-assessment relationship

**04-validateAssessmentIdWasLinked.js**
- Validates assessment_id was properly linked to conversation
- Tests database relationship integrity

**05-validateAssessmentObjectWasLinked.js**
- **Critical test**: Validates assessment_object was accessible via assessment_id
- Tests automatic object retrieval functionality in codebase
- Identifies if assessment object linking fails (current potential issue)

### Phase 3: Message Exchange
**06-sendUserMessage.js**
- Sends initial user message using prepared string content
- Tests user message creation and storage

**07-recieveChatbotResponse.js**
- Receives chatbot response (GEMINI or mock AI)
- Tests AI integration and response generation
- Validates response is properly stored

**08-sendUserMessageFollowup.js**
- Sends second user message (DRY principles, reusing logic from step 6)
- Uses different string from prepared messages
- Tests ongoing conversation flow

**09-recieveChatbotResponseFollowup.js**
- Receives second chatbot response
- Tests continued AI conversation handling

### Phase 4: Conversation Validation
**10-getConversation.js**
- Retrieves conversation details
- **Validates exactly 4 messages are attached** (2 user + 2 assistant)
- Tests conversation data integrity

**11-getConversation-ValidateMessageOrder.js**
- **Critical bug test**: Validates message sequence is correct
- Expected order: user → assistant → user → assistant
- **Addresses known production bug** with message ordering

**12-getConversationHistory.js**
- Validates conversation history retrieval as list
- Tests historical data access functionality

### Phase 5: Cleanup
**13-deleteConversation.js**
- Cleans up test conversation
- Ensures test isolation and prevents data pollution

## Key Testing Goals

### Assessment Integration
- Tests assessment_id → assessment_object relationship
- Validates backend can access assessment data for context-aware responses
- Identifies integration failures between assessment and chat systems

### Message Ordering (Production Bug)
- **Step 11** specifically addresses known production issue
- Ensures messages maintain correct chronological order
- Critical for conversation coherence

### Data Integrity
- Validates conversation-assessment linking
- Tests message count accuracy
- Ensures proper data relationships

## Usage
```javascript
// Run complete workflow
import { runChatWorkflow } from './index.js';
await runChatWorkflow();

// Run individual steps for debugging
import { prepareUserMessageString } from './01-prepareUserMessageString.js';
const messages = await prepareUserMessageString();
```

## Dependencies
- Requires existing assessment data from previous test setup
- Uses either GEMINI AI or mock AI responses
- Depends on proper database configuration

## Notes
- Steps 2 and 3 from previous workflow merged into step 1 (prepareUserMessageString)
- Follows DRY principles where possible (steps 6 and 8 share logic)
- Comprehensive validation ensures production bugs are caught in testing